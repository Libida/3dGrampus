<!DOCTYPE HTML>
<html>
<head>
    <style>
        body {
            margin: 0px;
            padding: 0px;
        }
    </style>
    <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>

</head>
<body>
<div id="container"></div>
<script src="js/three.js"></script>
<script defer="defer">
    // revolutions per second
    var angularSpeed = 0.2;
    var count = 0.1,
            moveBodyCount = 0.1,
            ncount = 0.01;

    function animate() {
        grampus.moveBody();
        requestAnimationFrame( animate );
    }


    var grampus = {
        settings: {
            threeJS: {
                renderer: {},
                camera: {},
                scene: {}
            },
            anatomy: {
                body: {
                    bodyGeometricObject: {},
                    cylinders: {
                        count: 4,
                        diameter: {
                            start: 50,
                            end: 150,
                            diff: 25
                        }
                    },
                    smoothTransitionNeeded: false,
                    moveBodyToPointFinished: []
                }
            },
            mouse: {
                x: 0,
                y: 0,
                xDiff: 0,
                yDiff: 0
            }
        },

        init: function () {
            this.initThreeJS();
            this.drawBody();
            this.bindEvents();
        },

        bindEvents: function () {
            var self = this;
            self.animateMoveBody();
            document.addEventListener( 'mousemove', self.onMouseMove, false );
        },

        onMouseMove: function (event) {
            var mouse = grampus.settings.mouse,
                    prevY = mouse.y;
            mouse.x = ( event.clientX - window.innerWidth / 2 ) ;
            mouse.y =   -( event.clientY - window.innerHeight / 2 );
            mouse.yDiff = mouse.y - prevY;
            if ((Math.abs(mouse.yDiff) >= 10) && !grampus.settings.anatomy.body.smoothTransitionNeeded) {
                grampus.settings.anatomy.body.smoothTransitionNeeded = true;
                console.log(mouse.yDiff);
                grampus.animateMoveBodyToPoint();
            }
        },

        moveBodyToPoint: function () {
            var self = this,
                    body = self.settings.anatomy.body.bodyGeometricObject,
                    bodyCylinders = body.children,
                    coordinates = self.settings.mouse;
            console.log(self.settings.anatomy.body.moveBodyToPointFinished);

            for (var i = 0; i < bodyCylinders.length; i++) {
                var currentCylinder = bodyCylinders[i];
//                currentCylinder.position.y = (Math.sin( ( i*2 - count ) * 0.3 ) * 100 + coordinates.y)/(ncount*100);
                //currentCylinder.position.y = (Math.sin( ( i*2 - count ) * 0.3 ) * 100 + coordinates.y)/(ncount*200);
                if (Math.floor(currentCylinder.position.y) != Math.floor(coordinates.y)) {
                    currentCylinder.position.y += (coordinates.y - currentCylinder.position.y) / (ncount*1000);
                }
                else {
                    if ( !( i in self.settings.anatomy.body.moveBodyToPointFinished ) ) {
                        self.settings.anatomy.body.moveBodyToPointFinished[i] = currentCylinder;
                    }
                }
//                currentCylinder.position.x = coordinates.x;
                count += 0.03;
                ncount += 0.00001;
            }

            console.log(self.settings.anatomy.body.moveBodyToPointFinished.length);

            if (self.settings.anatomy.body.moveBodyToPointFinished.length == self.settings.anatomy.body.cylinders.count) {
                self.settings.anatomy.body.smoothTransitionNeeded = false;
                console.log(self.settings.anatomy.body.smoothTransitionNeeded);
                self.settings.anatomy.body.moveBodyToPointFinished = {};
                count = 0.1;
                ncount = 0.1;
            }

            self.renderThreeJSResults();

        },

        animateMoveBodyToPoint: function() {
            var self = this;
            window.requestAnimationFrame(function() {
                if (self.settings.anatomy.body.smoothTransitionNeeded) {
                    self.moveBodyToPoint();
                    self.animateMoveBodyToPoint();
                }
            });

        },

        moveBody: function () {
            var self = this,
                body = self.settings.anatomy.body.bodyGeometricObject,
                bodyCylinders = body.children;

            for (var i = 0; i < bodyCylinders.length; i++) {
                var currentCylinder = bodyCylinders[i];
//                currentCylinder.position.y = Math.sin( ( i*2 + count ) * 0.3 ) * 10 + coordinates.y/(i+1);


//                console.log("y =" + coordinates.y + "; diff = " + coordinates.yDiff);

//                if (Math.abs(coordinates.yDiff) >= 30) {
                    currentCylinder.position.y = Math.sin( ( i*2 - moveBodyCount ) * 0.3 ) * 100;
//                }
  //              else {
//                    currentCylinder.position.y = coordinates.y/(bodyCylinders.length - i);
    //            }
//                if ((bodyCylinders[0].position.y >= window.innerHeight/2) || (bodyCylinders[0].position.y < -window.innerHeight/2)) {
//                    currentCylinder.position.y = coordinates.y;
//                    currentCylinder.position.x = coordinates.x;
//                }
                moveBodyCount += 0.03;
            }
            grampus.renderThreeJSResults();

        },

        animateMoveBody: function() {
            var self = this;
            window.requestAnimationFrame(function() {
                console.log(self.settings.anatomy.body.smoothTransitionNeeded);
                if (!self.settings.anatomy.body.smoothTransitionNeeded) {
                    self.moveBody();
                }
                self.animateMoveBody();
            });

        },



        initThreeJS: function () {
            var threeJS = this.settings.threeJS;
            threeJS.renderer = new THREE.WebGLRenderer();
            threeJS.renderer.setSize(window.innerWidth - 20, window.innerHeight - 20);
            document.body.appendChild(threeJS.renderer.domElement);
            threeJS.camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 1000);
            threeJS.camera.position.z = 700;
            threeJS.scene = new THREE.Scene();
        },

        renderThreeJSResults: function () {
            var threeJS = this.settings.threeJS;
            threeJS.renderer.render(threeJS.scene, threeJS.camera);
        },

        drawBody: function () {
            var selfSettings = this.settings,
                    scene = selfSettings.threeJS.scene,
                    body = selfSettings.anatomy.body,
                    currentCircleDiameter = body.cylinders.diameter.start,
                    diameterDiff = body.cylinders.diameter.diff,
                    currentZ = 0;
            body.bodyGeometricObject = new THREE.Object3D();
            body.bodyGeometricObject.position.x = 0;
            scene.add(body.bodyGeometricObject);
            for (var i = 0; i < body.cylinders.count; i++) {
                this.drawBodyCircle(currentCircleDiameter, currentCircleDiameter + diameterDiff, currentZ);
                currentCircleDiameter += diameterDiff;
                currentZ += 150;
            }
            this.renderThreeJSResults();

        },

        drawBodyCircle: function (startDiameter, endDiameter, z) {
            var bodyObject = this.settings.anatomy.body.bodyGeometricObject;
            var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(startDiameter, endDiameter, 100, 50, 50, false), new THREE.MeshBasicMaterial({
                wireframe: true,
                color: 'blue'
            }));
            cylinder.position.x = 0;
            cylinder.position.y = 0;
            cylinder.position.z = z;
            cylinder.applyMatrix( new THREE.Matrix4().makeRotationX( Math.PI / 2 ) );
            bodyObject.add(cylinder);
        }
    };

    grampus.init();
</script>
</body>
</html>